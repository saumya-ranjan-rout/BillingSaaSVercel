Fixing Firebase Admin Initialization and Server Startup Issues
 
The error indicates that Firebase Admin is failing to initialize, which is causing the server to crash. Let's fix this by improving the error handling and making Firebase optional for development.
 
1. Updated app.ts with Better Error Handling
 
```typescript
// src/app.ts
import express from 'express';
import cors from 'cors';
import morgan from 'morgan';
import * as admin from 'firebase-admin';
import path from 'path';
import fs from 'fs';
import { initializeDatabase } from './config/database';
import { errorHandler } from './middleware/error.middleware';
import { extractTenantFromSubdomain } from './middleware/tenant.middleware';
import logger, { stream } from './utils/logger';
 
const app = express();
const PORT = process.env.PORT || 3000;
 
// Initialize Firebase Admin for push notifications (optional)
const initializeFirebase = async (): Promise<boolean> => {
  try {
    const serviceAccountPath = path.join(__dirname, '../service-account-key.json');
    
    // Check if service account file exists
    if (!fs.existsSync(serviceAccountPath)) {
      logger.warn('Firebase service account file not found. Push notifications will be disabled.');
      return false;
    }
 
    const serviceAccount = require(serviceAccountPath);
    
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount)
    });
    
    logger.info('Firebase Admin initialized successfully');
    return true;
  } catch (error: any) {
    logger.error('Failed to initialize Firebase Admin', {
      error: error.message,
      stack: error.stack
    });
    return false;
  }
};
 
// Middleware
app.use(cors({
  origin: process.env.NODE_ENV === 'production'
    ? ['https://yourdomain.com', 'https://www.yourdomain.com']
    : ['http://192.168.29.17:3000', 'http://192.168.29.17:3001', 'http://192.168.29.17:3002'],
  credentials: true
}));
 
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
 
// HTTP request logging
app.use(morgan('combined', { stream }));
 
// Extract tenant from subdomain
app.use(extractTenantFromSubdomain);
 
// Initialize database and start server
const startServer = async () => {
  try {
    // Initialize Firebase (optional)
    await initializeFirebase();
    
    // Initialize database
    await initializeDatabase();
    logger.info('Database connected successfully');
    
    // Import routes after database is connected
    const authRoutes = require('./routes/auth.routes').default;
    const notificationRoutes = require('./routes/notification.routes').default;
    const syncRoutes = require('./routes/sync.routes').default;
    const ocrRoutes = require('./routes/ocr.routes').default;
 
    // Routes
    app.use('/api/auth', authRoutes);
    app.use('/api/notifications', notificationRoutes);
    app.use('/api/sync', syncRoutes);
    app.use('/api/ocr', ocrRoutes);
 
    // Health check endpoint
    app.get('/health', (req, res) => {
      res.json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        service: 'Billing SaaS API',
        version: process.env.npm_package_version || '1.0.0'
      });
    });
 
    // Error handling middleware (must be last)
    app.use(errorHandler);
 
    // 404 handler (must be after all routes)
    app.use('*', (req, res) => {
      logger.warn('Route not found', {
        path: req.originalUrl,
        method: req.method,
        ip: req.ip
      });
      
      res.status(404).json({
        success: false,
        message: 'Route not found'
      });
    });
 
    const server = app.listen(PORT, () => {
      logger.info(`Server running on port ${PORT}`);
      logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);
    });
 
    // Handle graceful shutdown
    const gracefulShutdown = async (signal: string) => {
      logger.info(`Received ${signal}. Starting graceful shutdown...`);
      
      server.close(() => {
        logger.info('HTTP server closed.');
        process.exit(0);
      });
 
      // Force close after 10 seconds
      setTimeout(() => {
        logger.error('Could not close connections in time, forcefully shutting down');
        process.exit(1);
      }, 10000);
    };
 
    // Listen for shutdown signals
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));
    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
 
  } catch (error: any) {
    logger.error('Failed to start server:', {
      error: error.message,
      stack: error.stack
    });
    process.exit(1);
  }
};
 
// Start the application
startServer();
 
export default app;
```
 
2. Updated Notification Service with Firebase Fallback
 
```typescript
// src/services/notification.service.ts
import { getRepository } from 'typeorm';
import * as admin from 'firebase-admin';
import { User } from '../entities/User';
import { Notification } from '../entities/Notification';
import logger from '../utils/logger';
 
export class NotificationService {
  private isFirebaseInitialized = false;
 
  constructor() {
    // Check if Firebase is initialized
    this.isFirebaseInitialized = admin.apps.length > 0;
    
    if (!this.isFirebaseInitialized) {
      logger.warn('Firebase not initialized. Push notifications will be disabled.');
    }
  }
 
  async registerPushToken(userId: string, token: string, platform: string) {
    const userRepository = getRepository(User);
    await userRepository.update(userId, {
      pushToken: token
    });
  }
 
  async sendPushNotification(userId: string, title: string, body: string, data: any = {}) {
    const userRepository = getRepository(User);
    const notificationRepository = getRepository(Notification);
    
    const user = await userRepository.findOne({
      where: { id: userId }
    });
    
    if (!user) {
      throw new Error('User not found');
    }
 
    try {
      // Only send push notification if Firebase is initialized and user has a token
      if (this.isFirebaseInitialized && user.pushToken) {
        const message: admin.messaging.Message = {
          token: user.pushToken,
          notification: {
            title,
            body
          },
          data,
          apns: {
            payload: {
              aps: {
                sound: 'default',
                badge: 1
              }
            }
          }
        };
 
        await admin.messaging().send(message);
        logger.debug('Push notification sent successfully', { userId, title });
      } else if (!this.isFirebaseInitialized) {
        logger.warn('Push notification skipped - Firebase not initialized', { userId, title });
      } else if (!user.pushToken) {
        logger.warn('Push notification skipped - User has no push token', { userId, title });
      }
 
      // Save to database regardless of Firebase status
      const notification = notificationRepository.create({
        title,
        body,
        data,
        user,
        type: data.type || 'general',
        priority: data.priority || 'normal'
      });
 
      await notificationRepository.save(notification);
      logger.debug('Notification saved to database', { userId, title });
      
    } catch (error: any) {
      logger.error('Error in sendPushNotification', {
        error: error.message,
        stack: error.stack,
        userId,
        title
      });
      throw new Error('Failed to process notification');
    }
  }
 
  // ... rest of the methods remain the same
}
```
 
3. Create a Firebase Service Account Template
 
Create a template file for the Firebase service account to help developers set it up:
 
```json
// service-account-key.example.json
{
  "type": "service_account",
  "project_id": "your-project-id",
  "private_key_id": "your-private-key-id",
  "private_key": "-----BEGIN PRIVATE KEY-----\nYOUR_PRIVATE_KEY\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-xxxxx@your-project-id.iam.gserviceaccount.com",
  "client_id": "your-client-id",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-xxxxx%40your-project-id.iam.gserviceaccount.com"
}
```
 
4. Update README with Firebase Setup Instructions
 
Add these instructions to your README.md:
 
```markdown
## Firebase Setup (Optional)
 
Push notifications require Firebase Cloud Messaging (FCM). To enable this feature:
 
1. Create a Firebase project at https://console.firebase.google.com/
2. Generate a service account key:
   - Go to Project Settings > Service Accounts
   - Click "Generate New Private Key"
   - Download the JSON file
3. Save the JSON file as `service-account-key.json` in the root directory
4. The app will automatically use this for push notifications
 
If you don't need push notifications, you can skip this step. The app will still work without Firebase.
```
 
5. Environment Configuration
 
Update your .env file with these variables:
 
```env
# Server Configuration
NODE_ENV=development
PORT=3000
 
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=password
DB_NAME=billing_saas
 
# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-change-in-production
JWT_EXPIRES_IN=24h
 
# Firebase Configuration (Optional)
FIREBASE_ENABLED=false
```
 
Key Changes Made:
 
1. Improved Firebase Initialization: Added proper error handling and made Firebase optional
2. Better Error Logging: Enhanced error messages with more context and details
3. Graceful Degradation: The app will continue to work even if Firebase fails to initialize
4. Service Account Check: Added file existence check before trying to load the service account
5. Notification Service Resilience: The service will work with or without Firebase
6. Documentation: Added clear instructions for setting up Firebase
 
These changes should resolve the startup issues you're experiencing. The application will now:
 
路 Start successfully even if Firebase is not configured
路 Provide clear warning messages when Firebase is not available
路 Continue to function with all other features working properly
路 Allow you to add Firebase support later without code changes